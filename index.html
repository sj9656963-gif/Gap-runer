<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í‹ˆìƒˆ í†µê³¼ ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
        }

        #gameInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 998;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 16px;
        }

        #gameInfo div {
            margin: 5px 0;
            white-space: nowrap;
        }

        /* ëª¨ë°”ì¼ì—ì„œ í°íŠ¸ í¬ê¸° ì¡°ì • */
        @media (max-width: 768px) {
            #gameInfo {
                font-size: 14px;
                padding: 8px 12px;
            }
        }

        .controls {
            display: none; /* í„°ì¹˜ë¡œ ì í”„ ë©”ì‹œì§€ ìˆ¨ê¹€ */
        }

        canvas {
            cursor: pointer;
            touch-action: none; /* í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px 40px;
            border-radius: 20px;
            display: none;
            text-align: center;
            max-width: 90%;
            width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        #gameOver h2 {
            font-size: 42px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        #gameOver p {
            font-size: 20px;
            margin: 8px 0;
            line-height: 1.4;
        }

        #finalTime {
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
        }

        #newRecord {
            color: #00ff00;
            font-size: 18px;
            margin-top: 5px;
        }

        #restartBtn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #restartBtn:hover {
            background: #764ba2;
        }

        /* UI ë²„íŠ¼ë“¤ */
        .ui-buttons {
            position: fixed;
            top: 80px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 999;
        }

        .ui-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        .ui-btn:active {
            transform: scale(0.95);
        }

        /* ë¡œë”© í™”ë©´ */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        #loadingScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 30px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255,255,255,0.3);
            border-top: 6px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ì¼ì‹œì •ì§€ í™”ë©´ */
        #pauseScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #pauseScreen h2 {
            color: white;
            font-size: 48px;
        }

        /* íŠœí† ë¦¬ì–¼ í™”ë©´ */
        #tutorialScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .tutorial-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            text-align: center;
        }

        .tutorial-content h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .tutorial-content p {
            font-size: 18px;
            margin: 15px 0;
            line-height: 1.6;
        }

        .tutorial-content button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        /* ìµœê³  ê¸°ë¡ í‘œì‹œ */
        #bestScore {
            color: #FFD700;
            font-size: 18px;
            margin-top: 10px;
        }

        /* ì—…ì  ì•Œë¦¼ */
        #achievementNotification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: none;
            z-index: 2000;
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                top: -100px;
                opacity: 0;
            }
            to {
                top: 100px;
                opacity: 1;
            }
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 600px) {
            canvas {
                max-width: 100vw;
                max-height: 70vh;
            }
        }

    </style>
</head>
<body>
    <!-- ë¡œë”© í™”ë©´ -->
    <div id="loadingScreen">
        <img id="loadingCharacter" src="character.png" style="width: 150px; height: 150px; margin-bottom: 20px;">
        <h1 style="color: white; font-size: 48px; margin-bottom: 10px;">í‹ˆìƒˆ í†µê³¼ ê²Œì„</h1>
        <div class="loading-spinner"></div>
        <p style="color: white; margin-top: 20px;">ë¡œë”© ì¤‘...</p>
    </div>

    <!-- íŠœí† ë¦¬ì–¼ í™”ë©´ -->
    <div id="tutorialScreen">
        <div class="tutorial-content">
            <h2>ê²Œì„ ë°©ë²•</h2>
            <p>ğŸ“± <strong>í™”ë©´ì„ í„°ì¹˜</strong>í•˜ì—¬ ì í”„í•˜ì„¸ìš”!</p>
            <p>â±ï¸ ì¥ì• ë¬¼ì„ í”¼í•˜ë©° ìµœëŒ€í•œ ì˜¤ë˜ ìƒì¡´í•˜ì„¸ìš”</p>
            <p>ğŸ“ˆ ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë‚œì´ë„ê°€ ì˜¬ë¼ê°‘ë‹ˆë‹¤</p>
            <p>ğŸ† ìµœê³  ê¸°ë¡ì— ë„ì „í•˜ì„¸ìš”!</p>
            <button id="tutorialCloseBtn">ì‹œì‘í•˜ê¸°!</button>
        </div>
    </div>

    <!-- ì¼ì‹œì •ì§€ í™”ë©´ -->
    <div id="pauseScreen">
        <h2>â¸ï¸ ì¼ì‹œì •ì§€</h2>
    </div>

    <!-- ì—…ì  ì•Œë¦¼ -->
    <div id="achievementNotification"></div>

    <!-- UI ë²„íŠ¼ë“¤ -->
    <div class="ui-buttons">
        <button class="ui-btn" id="pauseBtn" title="ì¼ì‹œì •ì§€">â¸ï¸</button>
    </div>


    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div id="gameInfo">
            <div id="difficulty">ë‚œì´ë„: 1ë‹¨ê³„</div>
            <div id="bestScore">ìµœê³  ê¸°ë¡: 0.000ì´ˆ</div>
        </div>
        <div class="controls">
            í„°ì¹˜ë¡œ ì í”„!
        </div>
        <div id="gameOver">
            <h2>ê²Œì„ ì˜¤ë²„!</h2>
            <p id="finalTime"></p>
            <p id="newRecord" style="color: #FFD700; display: none;">ğŸ‰ ì‹ ê¸°ë¡!</p>
            <p id="achievementSummary"></p>
            <button id="restartBtn">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ë””ë°”ì´ìŠ¤ ê°ì§€ (ëª¨ë°”ì¼ vs PC)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

        // ë””ë°”ì´ìŠ¤ë³„ ì†ë„ ë°°ìœ¨
        const speedMultiplierDevice = isMobile ? 2.5 : 1; // ëª¨ë°”ì¼ì€ 2.5ë°° ë” ë¹ ë¥´ê²Œ

        // ìº”ë²„ìŠ¤ë¥¼ ì „ì²´ í™”ë©´ì— ë§ì¶¤
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ì˜¤ë””ì˜¤ ì„¤ì • (Web Audio API ì‚¬ìš©)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();
        let bgmGainNode = null;
        let bgmSource = null;
        let isMusicPlaying = false;

        // ë°°ê²½ìŒì•… ìƒì„± (ë°ê³  ê²½ì¾Œí•œ ë©œë¡œë””)
        function createBackgroundMusic() {
            if (isMusicPlaying) return;

            // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¬ê°œ
            audioContext.resume();

            isMusicPlaying = true;
            bgmGainNode = audioContext.createGain();
            bgmGainNode.gain.value = 0.08;
            bgmGainNode.connect(audioContext.destination);

            // ë” ë°ê³  ê²½ì¾Œí•œ ë©œë¡œë””: C-E-G-C-G-E-C-D-E
            const melody = [
                523.25, 659.25, 783.99, 1046.50, 783.99, 659.25, 523.25, 587.33,
                659.25, 783.99, 659.25, 523.25, 587.33, 659.25, 523.25, 659.25
            ];

            // ë² ì´ìŠ¤ ë¼ì¸ (ì˜¥íƒ€ë¸Œ ì•„ë˜)
            const bassLine = [
                261.63, 329.63, 392.00, 523.25, 392.00, 329.63, 261.63, 293.66,
                329.63, 392.00, 329.63, 261.63, 293.66, 329.63, 261.63, 329.63
            ];

            let noteIndex = 0;

            function playNote() {
                if (!isMusicPlaying) return;

                // ë©œë¡œë”” íŒŒíŠ¸
                const osc1 = audioContext.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.value = melody[noteIndex];

                const gain1 = audioContext.createGain();
                gain1.gain.setValueAtTime(0.04, audioContext.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.35);

                osc1.connect(gain1);
                gain1.connect(bgmGainNode);

                osc1.start(audioContext.currentTime);
                osc1.stop(audioContext.currentTime + 0.35);

                // ë² ì´ìŠ¤ íŒŒíŠ¸
                const osc2 = audioContext.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = bassLine[noteIndex];

                const gain2 = audioContext.createGain();
                gain2.gain.setValueAtTime(0.02, audioContext.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.35);

                osc2.connect(gain2);
                gain2.connect(bgmGainNode);

                osc2.start(audioContext.currentTime);
                osc2.stop(audioContext.currentTime + 0.35);

                noteIndex = (noteIndex + 1) % melody.length;
                setTimeout(playNote, 350);
            }

            playNote();
        }

        // ì£½ìŒ íš¨ê³¼ìŒ
        function playDeathSound() {
            audioContext.resume(); // ëª¨ë°”ì¼ ì˜¤ë””ì˜¤ ì¬ìƒ í—ˆìš©

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ì í”„ íš¨ê³¼ìŒ
        function playJumpSound() {
            audioContext.resume(); // ëª¨ë°”ì¼ ì˜¤ë””ì˜¤ ì¬ìƒ í—ˆìš©

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // ê²Œì„ ë³€ìˆ˜
        let gameTime = 0;
        let isGameOver = false;
        let gameStarted = false;
        let isPaused = false;
        let startTime = Date.now();
        let lastFrameTime = Date.now();
        let pauseStartTime = 0;
        let totalPauseTime = 0;

        // ì‚¬ìš´ë“œ ì„¤ì •
        let soundEnabled = true; // í•­ìƒ ON

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ê´€ë¦¬
        const STORAGE_KEY = 'jumpGameData';
        let bestScore = 0;
        let unlockedAchievements = [];

        // ì—…ì  ì •ì˜
        const achievements = [
            { id: 'survivor_10', name: 'ìƒì¡´ì', description: '10ì´ˆ ìƒì¡´', time: 10, unlocked: false },
            { id: 'survivor_30', name: 'ë„ì „ì', description: '30ì´ˆ ìƒì¡´', time: 30, unlocked: false },
            { id: 'survivor_60', name: 'ì „ë¬¸ê°€', description: '60ì´ˆ ìƒì¡´', time: 60, unlocked: false },
            { id: 'survivor_90', name: 'ë§ˆìŠ¤í„°', description: '90ì´ˆ ìƒì¡´', time: 90, unlocked: false },
            { id: 'survivor_120', name: 'ì „ì„¤', description: '120ì´ˆ ìƒì¡´', time: 120, unlocked: false }
        ];

        // íŒŒí‹°í´ ë°°ì—´
        let particles = [];

        // ë³„ ë°°ì—´ (í•œ ë²ˆë§Œ ìƒì„±)
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.5 + 0.5
                });
            }
        }

        // ë³„ ê·¸ë¦¬ê¸°
        function drawStars() {
            if (stars.length === 0) initStars();

            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ë…¸ì„ êµ¬ë¦„ ê·¸ë¦¬ê¸°
        function drawSunsetClouds() {
            // ì£¼í™©-ë¶„í™ë¹› êµ¬ë¦„ë“¤
            ctx.fillStyle = 'rgba(255, 150, 100, 0.4)';

            // ì²« ë²ˆì§¸ êµ¬ë¦„ (í•˜ë‹¨ ì¢Œì¸¡)
            ctx.beginPath();
            ctx.arc(80, canvas.height - 120, 50, 0, Math.PI * 2);
            ctx.arc(120, canvas.height - 130, 60, 0, Math.PI * 2);
            ctx.arc(160, canvas.height - 120, 50, 0, Math.PI * 2);
            ctx.fill();

            // ë‘ ë²ˆì§¸ êµ¬ë¦„ (í•˜ë‹¨ ì¤‘ì•™)
            ctx.fillStyle = 'rgba(255, 120, 150, 0.35)';
            ctx.beginPath();
            ctx.arc(200, canvas.height - 80, 40, 0, Math.PI * 2);
            ctx.arc(235, canvas.height - 85, 55, 0, Math.PI * 2);
            ctx.arc(270, canvas.height - 80, 45, 0, Math.PI * 2);
            ctx.fill();

            // ì„¸ ë²ˆì§¸ êµ¬ë¦„ (í•˜ë‹¨ ìš°ì¸¡)
            ctx.fillStyle = 'rgba(255, 180, 120, 0.3)';
            ctx.beginPath();
            ctx.arc(320, canvas.height - 100, 45, 0, Math.PI * 2);
            ctx.arc(360, canvas.height - 105, 50, 0, Math.PI * 2);
            ctx.fill();

            // ì‘ì€ êµ¬ë¦„ë“¤
            ctx.fillStyle = 'rgba(255, 200, 150, 0.25)';
            ctx.beginPath();
            ctx.arc(40, canvas.height - 60, 30, 0, Math.PI * 2);
            ctx.arc(65, canvas.height - 65, 35, 0, Math.PI * 2);
            ctx.fill();
        }

        // ìš°ì£¼ ë³„ ë°°ì—´ (ë” ë§ì´)
        let spaceStars = [];
        function initSpaceStars() {
            spaceStars = [];
            // 200ê°œì˜ ë³„ (ì¼ë°˜ ë°¤í•˜ëŠ˜ë³´ë‹¤ ë” ë§ì´)
            for (let i = 0; i < 200; i++) {
                spaceStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 2 + 0.3,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkleSpeed: Math.random() * 2 + 1
                });
            }
        }

        // ìš°ì£¼ ë³„ ê·¸ë¦¬ê¸° (ë°˜ì§ì„ íš¨ê³¼)
        function drawSpaceStars() {
            if (spaceStars.length === 0) initSpaceStars();

            const time = Date.now() / 1000;

            spaceStars.forEach(star => {
                const twinkle = (Math.sin(time * star.twinkleSpeed) + 1) / 2; // 0~1 ì‚¬ì´ ê°’
                const currentOpacity = star.opacity * (0.5 + twinkle * 0.5);

                ctx.fillStyle = `rgba(255, 255, 255, ${currentOpacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();

                // ë°ì€ ë³„ì€ ë¹›ë‚˜ëŠ” íš¨ê³¼
                if (star.radius > 1.5) {
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = `rgba(255, 255, 255, ${currentOpacity})`;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        // í–‰ì„±ë“¤ ê·¸ë¦¬ê¸°
        function drawPlanets() {
            // í† ì„± (ê³ ë¦¬ê°€ ìˆëŠ” í–‰ì„±) - ìš°ì¸¡ ìƒë‹¨
            const saturnX = canvas.width - 100;
            const saturnY = 80;
            const saturnRadius = 35;

            // í† ì„± ë³¸ì²´ (í™©ê¸ˆë¹›)
            const saturnGradient = ctx.createRadialGradient(saturnX - 10, saturnY - 10, 5, saturnX, saturnY, saturnRadius);
            saturnGradient.addColorStop(0, '#f4d03f');
            saturnGradient.addColorStop(0.7, '#d4a017');
            saturnGradient.addColorStop(1, '#8b6914');
            ctx.fillStyle = saturnGradient;
            ctx.beginPath();
            ctx.arc(saturnX, saturnY, saturnRadius, 0, Math.PI * 2);
            ctx.fill();

            // í† ì„± ê³ ë¦¬
            ctx.strokeStyle = 'rgba(200, 180, 140, 0.7)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.ellipse(saturnX, saturnY, saturnRadius + 20, saturnRadius / 2.5, Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(180, 160, 120, 0.5)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.ellipse(saturnX, saturnY, saturnRadius + 28, saturnRadius / 2.2, Math.PI / 6, 0, Math.PI * 2);
            ctx.stroke();

            // í™”ì„± (ë¶‰ì€ í–‰ì„±) - ì¢Œì¸¡ ì¤‘ì•™
            const marsX = 60;
            const marsY = canvas.height / 2;
            const marsRadius = 25;

            const marsGradient = ctx.createRadialGradient(marsX - 8, marsY - 8, 3, marsX, marsY, marsRadius);
            marsGradient.addColorStop(0, '#ff6b6b');
            marsGradient.addColorStop(0.6, '#d63031');
            marsGradient.addColorStop(1, '#8b0000');
            ctx.fillStyle = marsGradient;
            ctx.beginPath();
            ctx.arc(marsX, marsY, marsRadius, 0, Math.PI * 2);
            ctx.fill();

            // ì§€êµ¬ - ìš°ì¸¡ í•˜ë‹¨
            const earthX = canvas.width - 70;
            const earthY = canvas.height - 90;
            const earthRadius = 40;

            // ì§€êµ¬ ë³¸ì²´ (íŒŒë€ìƒ‰-ì´ˆë¡ìƒ‰)
            const earthGradient = ctx.createRadialGradient(earthX - 10, earthY - 10, 5, earthX, earthY, earthRadius);
            earthGradient.addColorStop(0, '#87ceeb');    // ë°ì€ í•˜ëŠ˜ìƒ‰
            earthGradient.addColorStop(0.4, '#4a90e2');  // ë°”ë‹¤ìƒ‰
            earthGradient.addColorStop(0.7, '#2e5f8a');  // ê¹Šì€ íŒŒë‘
            earthGradient.addColorStop(1, '#1a3a52');    // ê°€ì¥ìë¦¬
            ctx.fillStyle = earthGradient;
            ctx.beginPath();
            ctx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
            ctx.fill();

            // ëŒ€ë¥™ (ì´ˆë¡-ê°ˆìƒ‰)
            ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';

            // ì²« ë²ˆì§¸ ëŒ€ë¥™
            ctx.beginPath();
            ctx.ellipse(earthX - 10, earthY - 15, 12, 8, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            // ë‘ ë²ˆì§¸ ëŒ€ë¥™
            ctx.beginPath();
            ctx.ellipse(earthX + 15, earthY, 10, 15, -Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // ì„¸ ë²ˆì§¸ ì‘ì€ ëŒ€ë¥™
            ctx.beginPath();
            ctx.ellipse(earthX - 5, earthY + 18, 8, 6, Math.PI / 3, 0, Math.PI * 2);
            ctx.fill();

            // êµ¬ë¦„ (í°ìƒ‰)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(earthX + 5, earthY - 8, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(earthX - 15, earthY + 10, 5, 3, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // ë‹¬ ê·¸ë¦¬ê¸°
        function drawMoon() {
            const moonX = 80;
            const moonY = 100;
            const moonRadius = 40;

            // ë‹¬ ë³¸ì²´ (ë°ì€ íšŒë°±ìƒ‰)
            const moonGradient = ctx.createRadialGradient(moonX - 10, moonY - 10, 5, moonX, moonY, moonRadius);
            moonGradient.addColorStop(0, '#f5f5f5');
            moonGradient.addColorStop(0.6, '#d3d3d3');
            moonGradient.addColorStop(1, '#a9a9a9');
            ctx.fillStyle = moonGradient;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
            ctx.fill();

            // ë‹¬ í‘œë©´ í¬ë ˆì´í„°ë“¤
            ctx.fillStyle = 'rgba(150, 150, 150, 0.3)';

            // í° í¬ë ˆì´í„°
            ctx.beginPath();
            ctx.arc(moonX + 10, moonY - 5, 12, 0, Math.PI * 2);
            ctx.fill();

            // ì¤‘ê°„ í¬ë ˆì´í„°ë“¤
            ctx.beginPath();
            ctx.arc(moonX - 12, moonY + 10, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(moonX + 15, moonY + 15, 6, 0, Math.PI * 2);
            ctx.fill();

            // ì‘ì€ í¬ë ˆì´í„°ë“¤
            ctx.beginPath();
            ctx.arc(moonX - 8, moonY - 15, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(moonX + 5, moonY + 8, 4, 0, Math.PI * 2);
            ctx.fill();

            // ë‹¬ ë¹› íš¨ê³¼
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // ê´€ì¸¡ ê°€ëŠ¥í•œ ìš°ì£¼ ê·¸ë¦¬ê¸° (íƒ€ì›í˜• - ì‹œê°„ì— ë”°ë¼ ì¶•ì†Œ)
        function drawObservableUniverse() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // 25ë‹¨ê³„ì— ì§„ì…í•œ ì‹œê°„ ê³„ì‚° (240ì´ˆë¶€í„° 25ë‹¨ê³„ ì‹œì‘)
            const elapsedTime = gameStarted ? (Date.now() - startTime - totalPauseTime) / 1000 : 0;
            const timeIn25Stage = Math.max(0, elapsedTime - 240); // 240ì´ˆ = 24ë‹¨ê³„ ë

            // ìš°ì£¼ í¬ê¸°ê°€ ì‹œê°„ì— ë”°ë¼ ì¶•ì†Œ (60ì´ˆì— ê±¸ì³ ì ìœ¼ë¡œ ì¶•ì†Œ)
            const shrinkProgress = Math.min(timeIn25Stage / 60, 1); // 0~1
            const sizeMultiplier = 1 - shrinkProgress; // 1 -> 0

            let radiusX = canvas.width * 0.45 * sizeMultiplier;
            let radiusY = canvas.height * 0.35 * sizeMultiplier;

            // ì™„ì „íˆ ì¶•ì†Œë˜ë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ (í°ìƒ‰ ë°°ê²½ë§Œ)
            if (sizeMultiplier <= 0.01) return;

            // íƒ€ì›í˜• í´ë¦¬í•‘ ì˜ì—­ ì„¤ì •
            ctx.save();
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.clip();

            // ìš°ì£¼ ë°°ê²½ (ì¤‘ì‹¬ì—ì„œ ë°”ê¹¥ìœ¼ë¡œ ê·¸ë¼ë””ì–¸íŠ¸)
            const universeGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusX);
            universeGradient.addColorStop(0, '#1a1a3e');      // ì¤‘ì‹¬: ê¹Šì€ ë‚¨ìƒ‰
            universeGradient.addColorStop(0.3, '#0f0f2e');    // ì–´ë‘ìš´ ë‚¨ìƒ‰
            universeGradient.addColorStop(0.6, '#0a0a1e');    // ê±°ì˜ ê²€ì€ìƒ‰
            universeGradient.addColorStop(1, '#000000');      // ê°€ì¥ìë¦¬: ì™„ì „ ê²€ì€ìƒ‰
            ctx.fillStyle = universeGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ì€í•˜ìˆ˜ íš¨ê³¼ (ì¤‘ì‹¬ë¶€ì— ë°ì€ ë )
            const milkyWayGradient = ctx.createLinearGradient(0, centerY - 50, canvas.width, centerY + 50);
            milkyWayGradient.addColorStop(0, 'rgba(100, 100, 150, 0)');
            milkyWayGradient.addColorStop(0.3, 'rgba(150, 150, 200, 0.15)');
            milkyWayGradient.addColorStop(0.5, 'rgba(180, 180, 220, 0.25)');
            milkyWayGradient.addColorStop(0.7, 'rgba(150, 150, 200, 0.15)');
            milkyWayGradient.addColorStop(1, 'rgba(100, 100, 150, 0)');
            ctx.fillStyle = milkyWayGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ë³„ë“¤ (ë§¤ìš° ë¯¸ì„¸í•˜ê²Œë§Œ ë°˜ì§ì„)
            for (let i = 0; i < 300; i++) {
                const angle = (i / 300) * Math.PI * 2;
                const distance = (i % 100) / 100; // ê³ ì •ëœ ê±°ë¦¬
                const x = centerX + Math.cos(angle) * radiusX * distance * 0.95;
                const y = centerY + Math.sin(angle) * radiusY * distance * 0.95;
                const size = (i % 3) * 0.5 + 0.3; // ê³ ì •ëœ í¬ê¸°
                const baseOpacity = ((i % 10) / 10) * 0.6 + 0.2;
                const twinkle = Math.sin(elapsedTime * 0.5 + i * 0.1) * 0.1; // ë§¤ìš° ë¯¸ì„¸í•œ ë°˜ì§ì„

                ctx.fillStyle = `rgba(255, 255, 255, ${baseOpacity + twinkle})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // ì€í•˜ë‹¨ (Galaxy Clusters)
            const galaxyClusters = [
                { angle: 0.2, dist: 0.4, count: 8, color: 'rgba(150, 180, 255, 0.3)' },
                { angle: 1.5, dist: 0.55, count: 10, color: 'rgba(255, 200, 150, 0.25)' },
                { angle: 3.0, dist: 0.35, count: 6, color: 'rgba(200, 150, 255, 0.3)' },
                { angle: 4.5, dist: 0.65, count: 12, color: 'rgba(180, 220, 255, 0.28)' },
            ];

            galaxyClusters.forEach(cluster => {
                const clusterX = centerX + Math.cos(cluster.angle) * radiusX * cluster.dist;
                const clusterY = centerY + Math.sin(cluster.angle) * radiusY * cluster.dist;

                // ì€í•˜ë‹¨ ë°°ê²½ ë¹›
                const clusterGlow = ctx.createRadialGradient(clusterX, clusterY, 0, clusterX, clusterY, 40);
                clusterGlow.addColorStop(0, cluster.color);
                clusterGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = clusterGlow;
                ctx.beginPath();
                ctx.arc(clusterX, clusterY, 40, 0, Math.PI * 2);
                ctx.fill();

                // ì€í•˜ë‹¨ ë‚´ ê°œë³„ ì€í•˜ë“¤
                for (let g = 0; g < cluster.count; g++) {
                    const gAngle = (g / cluster.count) * Math.PI * 2;
                    const gDist = 10 + (g % 3) * 8;
                    const gx = clusterX + Math.cos(gAngle) * gDist;
                    const gy = clusterY + Math.sin(gAngle) * gDist;
                    const gSize = 3 + (g % 2) * 2;

                    const galaxyGradient = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
                    galaxyGradient.addColorStop(0, 'rgba(255, 240, 200, 0.6)');
                    galaxyGradient.addColorStop(0.5, 'rgba(200, 180, 255, 0.3)');
                    galaxyGradient.addColorStop(1, 'rgba(100, 100, 200, 0)');
                    ctx.fillStyle = galaxyGradient;
                    ctx.beginPath();
                    ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ë‚˜ì„  ì€í•˜ë“¤ (ì‘ì€ í¬ê¸°)
            const spiralGalaxies = [
                { x: centerX - radiusX * 0.3, y: centerY - radiusY * 0.2, size: 5 },
                { x: centerX + radiusX * 0.4, y: centerY + radiusY * 0.3, size: 4 },
                { x: centerX + radiusX * 0.2, y: centerY - radiusY * 0.5, size: 5.5 },
                { x: centerX - radiusX * 0.5, y: centerY + radiusY * 0.4, size: 4.5 },
                { x: centerX + radiusX * 0.1, y: centerY + radiusY * 0.15, size: 4 },
                { x: centerX - radiusX * 0.15, y: centerY - radiusY * 0.35, size: 4.5 },
            ];

            spiralGalaxies.forEach(galaxy => {
                const galaxyGradient = ctx.createRadialGradient(galaxy.x, galaxy.y, 0, galaxy.x, galaxy.y, galaxy.size);
                galaxyGradient.addColorStop(0, 'rgba(255, 220, 150, 0.6)');
                galaxyGradient.addColorStop(0.4, 'rgba(200, 180, 255, 0.3)');
                galaxyGradient.addColorStop(0.8, 'rgba(100, 120, 200, 0.1)');
                galaxyGradient.addColorStop(1, 'rgba(50, 50, 100, 0)');
                ctx.fillStyle = galaxyGradient;
                ctx.beginPath();
                ctx.arc(galaxy.x, galaxy.y, galaxy.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // í´ë¦¬í•‘ í•´ì œ
            ctx.restore();

            // íƒ€ì› í…Œë‘ë¦¬ (ìš°ì£¼ì˜ ê²½ê³„)
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
            ctx.stroke();

            // ì™¸ê³½ ë¹›ë‚˜ëŠ” íš¨ê³¼
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(150, 150, 200, 0.3)';
            ctx.strokeStyle = 'rgba(180, 180, 220, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX + 5, radiusY + 5, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë¡œë“œ
        function loadGameData() {
            const data = localStorage.getItem(STORAGE_KEY);
            if (data) {
                const parsed = JSON.parse(data);
                bestScore = parsed.bestScore || 0;
                unlockedAchievements = parsed.achievements || [];

                // ì—…ì  ë³µì›
                achievements.forEach(ach => {
                    if (unlockedAchievements.includes(ach.id)) {
                        ach.unlocked = true;
                    }
                });
            }
            updateBestScoreDisplay();
        }

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥
        function saveGameData() {
            const data = {
                bestScore: bestScore,
                achievements: unlockedAchievements
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        // ìµœê³  ê¸°ë¡ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateBestScoreDisplay() {
            document.getElementById('bestScore').textContent = `ìµœê³  ê¸°ë¡: ${bestScore.toFixed(3)}ì´ˆ`;
        }

        // íŒŒí‹°í´ í´ë˜ìŠ¤
        class Particle {
            constructor(x, y, color, velocityX, velocityY) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.alpha = 1;
                this.radius = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2; // ì¤‘ë ¥
                this.alpha -= 0.02;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.alpha <= 0;
            }
        }

        // íŒŒí‹°í´ ìƒì„±
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = Math.random() * 3 + 2;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed - 2;
                particles.push(new Particle(x, y, color, velocityX, velocityY));
            }
        }

        // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
        function updateAndDrawParticles() {
            particles = particles.filter(p => !p.isDead());
            particles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        // ì—…ì  í™•ì¸
        function checkAchievements(time) {
            achievements.forEach(ach => {
                if (!ach.unlocked && time >= ach.time) {
                    ach.unlocked = true;
                    unlockedAchievements.push(ach.id);
                    showAchievementNotification(ach);
                    saveGameData();
                }
            });
        }

        // ì—…ì  ì•Œë¦¼ í‘œì‹œ
        function showAchievementNotification(achievement) {
            const notif = document.getElementById('achievementNotification');
            notif.textContent = `ğŸ† ${achievement.name} ë‹¬ì„±!`;
            notif.style.display = 'block';

            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        // ì§„ë™ í”¼ë“œë°± (ëª¨ë°”ì¼)
        function vibrate(duration = 50) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        // ìºë¦­í„° ì´ë¯¸ì§€ ë¡œë“œ
        const characterImg = new Image();
        characterImg.src = 'character.png';
        let imageLoaded = false;
        characterImg.onload = function() {
            imageLoaded = true;
            // ë¡œë”© ì™„ë£Œ í›„ ë¡œë”© í™”ë©´ ìˆ¨ê¸°ê¸°
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                // ì²« ì‹¤í–‰ ì‹œ íŠœí† ë¦¬ì–¼ í‘œì‹œ
                if (!localStorage.getItem(STORAGE_KEY)) {
                    document.getElementById('tutorialScreen').style.display = 'flex';
                }
            }, 1000);
        };

        // ê³µ ì„¤ì •
        const ball = {
            x: 200,
            y: 100,
            radius: 15,
            velocityY: 0,
            gravity: 0.25,      // 0.15 â†’ 0.25 ì¦ê°€
            jumpPower: -7,      // -5.5 â†’ -7 ì¦ê°€
            canJump: true
        };

        // ì¥ì• ë¬¼ ë°°ì—´
        let obstacles = [];
        let obstacleSpeed = 2;          // PC ê¸°ì¤€ ì†ë„
        let obstacleSpawnRate = 140;    // PC ê¸°ì¤€ ìƒì„± ê°„ê²©
        let frameCount = 0;

        // ë‚œì´ë„ ì„¤ì •
        let difficultyLevel = 1;
        const maxDifficulty = 25;

        // ì¥ì• ë¬¼ ìƒì„±
        function createObstacle() {
            const elapsedTime = gameStarted ? (Date.now() - startTime - totalPauseTime) / 1000 : 0;

            // ì‹œê°„ì— ë”°ë¼ ê°„ê²©ì´ ì ì  ì¢ì•„ì§
            const maxGap = 250;
            const minGap = 70;
            const gapReduction = Math.min(elapsedTime * 0.72, maxGap - minGap);
            const gap = Math.max(minGap, maxGap - gapReduction);

            const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;

            obstacles.push({
                x: canvas.width,
                topHeight: gapPosition,
                bottomY: gapPosition + gap,
                width: 50,
                passed: false
            });
        }

        // ë‚œì´ë„ ì—…ë°ì´íŠ¸
        function updateDifficulty() {
            const elapsedTime = gameStarted ? (Date.now() - startTime - totalPauseTime) / 1000 : 0;

            // ì‹œê°„ì— ë”°ë¼ ì†ë„ê°€ ì ì  ë¹¨ë¼ì§
            const speedMultiplier = Math.min(1 + (elapsedTime * 0.044), 12);
            obstacleSpeed = 2 * speedMultiplier * speedMultiplierDevice; // ë””ë°”ì´ìŠ¤ë³„ ì†ë„ ë°°ìœ¨ ì ìš©

            // ì¥ì• ë¬¼ ìƒì„± ê°„ê²©ë„ ì ì  ì§§ì•„ì§
            const spawnReduction = Math.min(elapsedTime * 0.5, 125);
            obstacleSpawnRate = Math.max(15, 140 - spawnReduction);

            // ë‚œì´ë„ ë ˆë²¨ í‘œì‹œ (10ì´ˆë§ˆë‹¤ 1ë‹¨ê³„ì”© ì¦ê°€)
            const newLevel = Math.min(Math.floor(elapsedTime / 10) + 1, maxDifficulty);
            if (newLevel !== difficultyLevel) {
                difficultyLevel = newLevel;
                document.getElementById('difficulty').textContent = `ë‚œì´ë„: ${difficultyLevel}ë‹¨ê³„`;
            }
        }

        // ìºë¦­í„° ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        function drawBall() {
            const centerX = ball.x;
            const centerY = ball.y;
            const size = ball.radius * 2; // ì´ë¯¸ì§€ í¬ê¸° (ì§ê²½)

            // ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆìœ¼ë©´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°, ì•„ë‹ˆë©´ ê¸°ë³¸ ì› ê·¸ë¦¬ê¸°
            if (imageLoaded) {
                ctx.save();

                // ì´ë¯¸ì§€ë¥¼ ì¤‘ì‹¬ì  ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                ctx.drawImage(
                    characterImg,
                    centerX - size,
                    centerY - size,
                    size * 2,
                    size * 2
                );

                ctx.restore();
            } else {
                // ì´ë¯¸ì§€ ë¡œë”© ì¤‘ì¼ ë•ŒëŠ” ê¸°ë³¸ ì› í‘œì‹œ
                ctx.beginPath();
                ctx.arc(centerX, centerY, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD54F';
                ctx.fill();
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                // ìœ„ìª½ ì¥ì• ë¬¼
                const gradient1 = ctx.createLinearGradient(obstacle.x, 0, obstacle.x + obstacle.width, 0);
                gradient1.addColorStop(0, '#2E7D32');
                gradient1.addColorStop(1, '#4CAF50');

                ctx.fillStyle = gradient1;
                ctx.fillRect(obstacle.x, 0, obstacle.width, obstacle.topHeight);
                ctx.strokeStyle = '#1B5E20';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, 0, obstacle.width, obstacle.topHeight);

                // ì•„ë˜ìª½ ì¥ì• ë¬¼
                const gradient2 = ctx.createLinearGradient(obstacle.x, obstacle.bottomY, obstacle.x + obstacle.width, canvas.height);
                gradient2.addColorStop(0, '#2E7D32');
                gradient2.addColorStop(1, '#4CAF50');

                ctx.fillStyle = gradient2;
                ctx.fillRect(obstacle.x, obstacle.bottomY, obstacle.width, canvas.height - obstacle.bottomY);
                ctx.strokeStyle = '#1B5E20';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.bottomY, obstacle.width, canvas.height - obstacle.bottomY);
            });
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision() {
            // ë°”ë‹¥ê³¼ ì²œì¥ ì¶©ëŒ
            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                endGame();
                return;
            }

            // ì¥ì• ë¬¼ ì¶©ëŒ
            obstacles.forEach(obstacle => {
                if (ball.x + ball.radius > obstacle.x &&
                    ball.x - ball.radius < obstacle.x + obstacle.width) {

                    if (ball.y - ball.radius < obstacle.topHeight ||
                        ball.y + ball.radius > obstacle.bottomY) {
                        endGame();
                    }
                }
            });
        }

        // ê³µ ì—…ë°ì´íŠ¸
        function updateBall() {
            if (gameStarted) {
                ball.velocityY += ball.gravity;
                ball.y += ball.velocityY;
            }
        }

        // ì¥ì• ë¬¼ ì—…ë°ì´íŠ¸
        function updateObstacles() {
            if (!gameStarted) return;

            obstacles.forEach((obstacle, index) => {
                obstacle.x -= obstacleSpeed;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì¥ì• ë¬¼ ì œê±°
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                }
            });

            // ìƒˆ ì¥ì• ë¬¼ ìƒì„±
            frameCount++;
            if (frameCount > obstacleSpawnRate) {
                createObstacle();
                frameCount = 0;
            }
        }

        // ê²Œì„ ì‹œì‘
        function startGame() {
            if (!gameStarted && !isGameOver) {
                gameStarted = true;
                startTime = Date.now();

                // ëª¨ë°”ì¼ ì˜¤ë””ì˜¤ í™œì„±í™” í›„ ë°°ê²½ìŒì•… ì‹œì‘
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createBackgroundMusic();
                    });
                } else {
                    createBackgroundMusic();
                }
            }
        }

        // ì í”„
        function jump() {
            if (!gameStarted) {
                startGame();
                return; // ê²Œì„ ì‹œì‘ ì‹œì—ëŠ” ì í”„í•˜ì§€ ì•ŠìŒ
            }
            if (isPaused) return; // ì¼ì‹œì •ì§€ ì¤‘ì—ëŠ” ì í”„ ë¶ˆê°€
            if (ball.canJump && !isGameOver && gameStarted) {
                ball.velocityY = ball.jumpPower;
                ball.canJump = false;
                playJumpSound(); // ì í”„ íš¨ê³¼ìŒ
                createParticles(ball.x, ball.y, '#FFD54F', 8); // ì í”„ íŒŒí‹°í´
                vibrate(30); // ì§„ë™ í”¼ë“œë°±
            }
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame() {
            if (isGameOver) return;

            isGameOver = true;
            isMusicPlaying = false; // ë°°ê²½ìŒì•… ì¤‘ì§€
            playDeathSound(); // ì£½ìŒ íš¨ê³¼ìŒ

            const finalTime = parseFloat(((Date.now() - startTime - totalPauseTime) / 1000).toFixed(3));
            document.getElementById('finalTime').textContent = `ê¸°ë¡: ${finalTime.toFixed(3)}ì´ˆ`;

            // ì¶©ëŒ íŒŒí‹°í´
            createParticles(ball.x, ball.y, '#FF6B6B', 20);
            vibrate(200); // ê°•í•œ ì§„ë™

            // ì‹ ê¸°ë¡ í™•ì¸
            const newRecord = document.getElementById('newRecord');
            if (finalTime > bestScore) {
                bestScore = finalTime;
                saveGameData();
                updateBestScoreDisplay();
                newRecord.style.display = 'block';
            } else {
                newRecord.style.display = 'none';
            }

            // ì—…ì  ìš”ì•½
            const unlockedCount = achievements.filter(a => a.unlocked).length;
            document.getElementById('achievementSummary').textContent =
                `ì—…ì : ${unlockedCount}/${achievements.length} ë‹¬ì„±`;

            document.getElementById('gameOver').style.display = 'block';
        }

        // ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            ball.x = 200;
            ball.y = 100;
            ball.velocityY = 0;
            ball.canJump = true;

            gameTime = 0;
            isGameOver = false;
            gameStarted = false;
            isPaused = false;
            obstacles = [];
            particles = [];
            frameCount = 0;
            difficultyLevel = 1;
            obstacleSpeed = 2;
            obstacleSpawnRate = 140;
            totalPauseTime = 0;
            stars = []; // ë³„ ì´ˆê¸°í™”
            spaceStars = []; // ìš°ì£¼ ë³„ ì´ˆê¸°í™”

            startTime = Date.now();

            document.getElementById('difficulty').textContent = 'ë‚œì´ë„: 1ë‹¨ê³„';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';

            gameLoop();
        }


        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (isGameOver) return;
            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ë‚œì´ë„ë³„ ë°°ê²½ ìƒ‰ìƒ ë³€í™”
            const elapsedTime = gameStarted ? (Date.now() - startTime - totalPauseTime) / 1000 : 0;
            let bgColor1, bgColor2;

            if (difficultyLevel >= 25) {
                // 25ë‹¨ê³„: ê´€ì¸¡ ê°€ëŠ¥í•œ ìš°ì£¼ (íƒ€ì›í˜•)
                // í°ìƒ‰ ë°°ê²½
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ê´€ì¸¡ ê°€ëŠ¥í•œ ìš°ì£¼ (íƒ€ì›í˜•)
                drawObservableUniverse();
            } else if (difficultyLevel >= 20) {
                // 20~24ë‹¨ê³„: ìš°ì£¼ ê³µê°„
                // ê¹Šì€ ê²€ì€ ìš°ì£¼ ë°°ê²½
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ë¨¼ ë³„ë“¤ (ë” ë§ì´)
                drawSpaceStars();

                // í–‰ì„±ë“¤ ê·¸ë¦¬ê¸°
                drawPlanets();

                // ë‹¬ ê·¸ë¦¬ê¸°
                drawMoon();
            } else if (difficultyLevel >= 15) {
                // 15~19ë‹¨ê³„: ì™„ì „ ë°¤ + ë³„
                bgColor1 = '#0a0e27';
                bgColor2 = '#1a1a3e';

                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, bgColor1);
                gradient.addColorStop(1, bgColor2);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ë³„ ê·¸ë¦¬ê¸°
                drawStars();
            } else if (difficultyLevel >= 10) {
                // 10~14ë‹¨ê³„: ë°¤ì´ ì°¾ì•„ì˜¤ëŠ” í•˜ëŠ˜ (ìƒë‹¨ì€ ë‚¨ìƒ‰~ë³´ë¼, í•˜ë‹¨ì€ ë…¸ì„)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a1a3e');      // ìƒë‹¨: ê¹Šì€ ë‚¨ìƒ‰
                gradient.addColorStop(0.3, '#2d1b4e');    // ë³´ë¼ë¹›
                gradient.addColorStop(0.5, '#4a2c5e');    // ì—°í•œ ë³´ë¼
                gradient.addColorStop(0.7, '#7d4e7f');    // ë³´ë¼-í•‘í¬
                gradient.addColorStop(0.85, '#ff6b9d');   // ë¶„í™ë¹› ë…¸ì„
                gradient.addColorStop(1, '#ffa07a');      // í•˜ë‹¨: ì£¼í™© ë…¸ì„
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ë…¸ì„ êµ¬ë¦„ (í•˜ë‹¨ë¶€)
                drawSunsetClouds();
            } else if (difficultyLevel >= 5) {
                // 5~9ë‹¨ê³„: ë…¸ì„ (ë” í™”ë ¤í•œ ê·¸ë¼ë””ì–¸íŠ¸)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#ff6b6b');      // ìƒë‹¨: ë¹¨ê°•
                gradient.addColorStop(0.25, '#ff8e53');   // ì£¼í™©
                gradient.addColorStop(0.5, '#ffa07a');    // ì—°í•œ ì£¼í™©
                gradient.addColorStop(0.7, '#ffb88c');    // ì‚´êµ¬ìƒ‰
                gradient.addColorStop(0.85, '#ffd4a3');   // í¬ë¦¼ìƒ‰
                gradient.addColorStop(1, '#ffe5b4');      // í•˜ë‹¨: ë°ì€ í¬ë¦¼
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ë…¸ì„ êµ¬ë¦„
                drawSunsetClouds();
            } else {
                // 1~4ë‹¨ê³„: ë°ì€ í•˜ëŠ˜
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');      // ìƒë‹¨: í•˜ëŠ˜ìƒ‰
                gradient.addColorStop(0.5, '#b0d9f7');    // ì¤‘ê°„
                gradient.addColorStop(1, '#E0F6FF');      // í•˜ë‹¨: ë°ì€ í•˜ëŠ˜
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // êµ¬ë¦„ íš¨ê³¼ (ë°ì€ í•˜ëŠ˜ì¼ ë•Œë§Œ)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                // ì²« ë²ˆì§¸ êµ¬ë¦„
                ctx.beginPath();
                ctx.arc(100, 100, 40, 0, Math.PI * 2);
                ctx.arc(130, 95, 50, 0, Math.PI * 2);
                ctx.arc(160, 100, 40, 0, Math.PI * 2);
                ctx.fill();

                // ë‘ ë²ˆì§¸ êµ¬ë¦„
                ctx.beginPath();
                ctx.arc(280, 180, 35, 0, Math.PI * 2);
                ctx.arc(310, 175, 45, 0, Math.PI * 2);
                ctx.arc(340, 180, 35, 0, Math.PI * 2);
                ctx.fill();

                // ì„¸ ë²ˆì§¸ ì‘ì€ êµ¬ë¦„
                ctx.beginPath();
                ctx.arc(50, 250, 25, 0, Math.PI * 2);
                ctx.arc(70, 245, 30, 0, Math.PI * 2);
                ctx.arc(90, 250, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            // ê²Œì„ ì‹œì‘ ì „ ì•ˆë‚´ ë©”ì‹œì§€
            if (!gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(50, 250, 300, 100);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('í„°ì¹˜í•˜ì—¬', 200, 285);
                ctx.fillText('ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!', 200, 320);
                ctx.textAlign = 'left';
            }

            // ê²Œì„ ì‹œê°„ ì—…ë°ì´íŠ¸
            if (gameStarted) {
                const elapsedTime = (Date.now() - startTime - totalPauseTime) / 1000;
                const displayTime = elapsedTime.toFixed(3);
                const currentTime = Math.floor(elapsedTime);

                // ë§¤ í”„ë ˆì„ë§ˆë‹¤ ë‚œì´ë„ ì—…ë°ì´íŠ¸ (ì†ë„ì™€ ê°„ê²©ì´ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€í•¨)
                updateDifficulty();

                // ì—…ì  í™•ì¸
                checkAchievements(elapsedTime);

                if (currentTime !== gameTime) {
                    gameTime = currentTime;
                }

                // ìš°ì¸¡ ìƒë‹¨ì— ì‹œê°„ í‘œì‹œ
                const timeStr = elapsedTime.toFixed(3);

                // ë°˜ì‘í˜• í¬ê¸° ì„¤ì •
                const boxWidth = isMobile ? 120 : 145;
                const boxHeight = isMobile ? 45 : 55;
                const titleFontSize = isMobile ? 12 : 14;
                const timeFontSize = isMobile ? 18 : 22;
                const boxX = canvas.width - boxWidth - 10;
                const boxY = 15;

                // ë°°ê²½ ë°•ìŠ¤
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // íƒ€ì´í‹€
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${titleFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('TIME', boxX + boxWidth / 2, boxY + titleFontSize + 8);

                // ì‹œê°„ í‘œì‹œ
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${timeFontSize}px Consolas, monospace`;
                ctx.textAlign = 'center';
                ctx.fillText(timeStr + 's', boxX + boxWidth / 2, boxY + boxHeight - 8);

                ctx.textAlign = 'left';
            }

            // ì—…ë°ì´íŠ¸
            updateBall();
            updateObstacles();

            // ê·¸ë¦¬ê¸°
            drawObstacles();
            drawBall();
            updateAndDrawParticles(); // íŒŒí‹°í´ ê·¸ë¦¬ê¸°

            // ì¶©ëŒ ê°ì§€
            checkCollision();

            requestAnimationFrame(gameLoop);
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ - í„°ì¹˜ ë° í´ë¦­
        function handleJump() {
            jump();
            setTimeout(() => {
                ball.canJump = true;
            }, 100);
        }

        // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // ê¸°ë³¸ í„°ì¹˜ ë™ì‘ ë°©ì§€
            handleJump();
        });

        // í´ë¦­ ì´ë²¤íŠ¸ (PC)
        canvas.addEventListener('click', () => {
            handleJump();
        });

        document.getElementById('restartBtn').addEventListener('click', resetGame);


        // UI ë²„íŠ¼ ì´ë²¤íŠ¸
        // ì¼ì‹œì •ì§€
        document.getElementById('pauseBtn').addEventListener('click', () => {
            if (isGameOver || !gameStarted) return;

            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'â–¶ï¸' : 'â¸ï¸';
            document.getElementById('pauseScreen').style.display = isPaused ? 'flex' : 'none';

            if (isPaused) {
                pauseStartTime = Date.now();
                isMusicPlaying = false;
            } else {
                // ì¼ì‹œì •ì§€ í•´ì œ
                totalPauseTime += Date.now() - pauseStartTime;
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createBackgroundMusic();
                    });
                } else {
                    createBackgroundMusic();
                }
            }
        });

        // ì¼ì‹œì •ì§€ í™”ë©´ í´ë¦­ ì‹œ ì¬ê°œ
        document.getElementById('pauseScreen').addEventListener('click', () => {
            if (isPaused && !isGameOver && gameStarted) {
                isPaused = false;
                document.getElementById('pauseBtn').textContent = 'â¸ï¸';
                document.getElementById('pauseScreen').style.display = 'none';

                totalPauseTime += Date.now() - pauseStartTime;
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createBackgroundMusic();
                    });
                } else {
                    createBackgroundMusic();
                }
            }
        });

        // íŠœí† ë¦¬ì–¼ ë‹«ê¸°
        document.getElementById('tutorialCloseBtn').addEventListener('click', () => {
            document.getElementById('tutorialScreen').style.display = 'none';
        });

        // í™”ë©´ ë¦¬ì‚¬ì´ì¦ˆ ë° ë°©í–¥ ì „í™˜ ì²˜ë¦¬
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 200;

            let newWidth = 400;
            let newHeight = 600;

            // ì„¸ë¡œ ëª¨ë“œ (ëª¨ë°”ì¼)
            if (window.innerWidth < window.innerHeight) {
                newWidth = Math.min(maxWidth, 400);
                newHeight = newWidth * 1.5;
            }
            // ê°€ë¡œ ëª¨ë“œ (ëª¨ë°”ì¼ ë˜ëŠ” íƒœë¸”ë¦¿)
            else if (window.innerWidth < 800) {
                newHeight = Math.min(maxHeight, 400);
                newWidth = newHeight * 0.667;
            }

            // ìº”ë²„ìŠ¤ í¬ê¸°ëŠ” ìœ ì§€í•˜ê³  CSSë¡œ ìŠ¤ì¼€ì¼ë§
            const scaleX = newWidth / 400;
            const scaleY = newHeight / 600;
            const scale = Math.min(scaleX, scaleY);

            canvas.style.width = (400 * scale) + 'px';
            canvas.style.height = (600 * scale) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // ì²« í„°ì¹˜/í´ë¦­ ì‹œ ìë™ ì „ì²´í™”ë©´
        // ëª¨ë°”ì¼ ì˜¤ë””ì˜¤ í™œì„±í™”
        function initAudio() {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed');
                });
            }
        }

        // ì²« í„°ì¹˜/í´ë¦­ ì‹œ ì˜¤ë””ì˜¤ í™œì„±í™”
        function handleFirstInteraction() {
            initAudio();
        }

        canvas.addEventListener('touchstart', handleFirstInteraction);
        canvas.addEventListener('click', handleFirstInteraction);

        // ì´ˆê¸° ì„¤ì •
        loadGameData();
        resizeCanvas();

        // ì´ˆê¸° ë Œë”ë§
        gameLoop();
    </script>
</body>
</html>